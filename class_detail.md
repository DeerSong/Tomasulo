## 实现细节

### 总调度类

#### main.Clock

该类在后端模拟器中处于一个管理调度的地位，并且提供总线数据的支持，其主要工作是对各个部件进行初始化，并对前段提供数据接口，便于交互。简单调度过程模拟可以参考Clock.main函数，里面实现了一个简单的后端指令执行流程的调度，用于调试。

接下来主要介绍Clock类的成员变量，即各个部件的变量名和其对应作用：

- queue : 指令队列模块
- addGroup, mulGroup, memGroup : 这三个变量分别是加减法，乘除法，内存操作缓冲队列


- adder, multiplier, memAccesser : 这三个变量是加减法，乘除法，内存操作(Load, Store)的运算部件
- fp : 寄存器组，包含两个子模块，
  - state : 寄存器状态，实际为保留站的指针，表示当前寄存器将由那个保留站写入
  - reg : 寄存器名称, F0 ~ F10
  - num : 寄存器的实际数据
- mem : 虚拟内存指针，创建了一个虚拟数组，代替内存地址空间，大小为4096。
- CDB_DATA : 数据总线上面的数据，没有保留站向其写数据的时候，默认为null。
- running_state : 程序运行状态的记录列表，实际上存储的是指令，而指令中含有指令当前的运行状态。
- clock, step : 这两个变量分别用来记录执行的周期数和多步执行时候的步进值。

### 子模块

下面介绍各个模块的实现细节，从指令执行流程的顺序进行介绍：

#### kernel.InstructionQueue

指令队列的设计主要分为三个部分：

- load() : 载入指令序列，可从文件载入，也可传入字符串数组，加载到指令队列中

- decodeInstr() : 将读入的指令字符串进行解码，这里会对指令格式进行判断，在这里，我们提供了丰富的指令格式，支持对tab，空格，逗号，左右括弧的支持，只是因为目前这个项目的支持格式有所限制，所以实际上并没有使用到这些匹配，但是这便于以后的扩展。详细的指令事例可以参考kernel.InstructionQueue.main函数，其中有一些指令格式序列。

  另外，如果指令格式出现错误，程序并不会立即终止运行，而是会跳过这条指令，并输出格式错误信息。对于不同的错误，我们支持了不同的输出信息，显示到前端的控制台上，满足用户体验。

- transfer() : 指令的流出操作，先根据指令的操作码，在对应的缓冲队列中寻找到空闲的保留站，并将指令数据设置到保留站中。在这里，因为要记录指令的运行状态，所以保留站中也存有指令的指针。

  在这里，存在一些需要讨论的问题：

  - 如果保留站已满，那么指令队列就不进行指令流出操作，直到保留站出现空位。
  - 另外我们保留站的设计是一个周期内，只流出一条指令，在我们看来，指令的流出在实际情况中，一个周期内流出一条也是合理的，所以我们如此设计。

#### kernel.AbstractHandler

算法中有三个运算部件，但是在实际系统设计中，我们发现各个运算部件的实际功能虽然存在些许差异，但是其流程及其相似，对外的提供的接口也大同小异。

他们都有流水段，并管理各自的缓冲队列。对外提供调度接口---activate()，调度执行流程也及其类似：

- 先检查第０段流水段，如果该流水段空闲, 表示没有指令正在执行或者指令已经进入下一段流水，这时需要在对应的缓冲队列中寻找一个可执行的保留站。如果找到，将之加载到流水段中。
- 逆向遍历流水段（注意，这里正向执行流水段中的指令会出现问题），如果该流水段中存在执行的指令，那么执行该流水段（时钟加１），执行完检查该流水段是否需要调度（进入到下一个流水段），如果需要，这是存在两种情况：
  - 该流水段是最后一个流水段，这意味着指令已经执行玩，那么需要实现指令真正的运算，这些不同的运算被封装在calFunc()函数中，不同的运算部件继承该类需要去实现自己的运算函数。
  - 该流水段不是最后一个流水段，那么需要检查该流水段的下一个流水段是否存在指令执行（这里要求逆向遍历流水段，这是正常的也是合理的），如果没有指令，那么交换当前流水段和下一个流水段，并通知流水段调度成功并从新流水段计时；否则，不交换，等待，直到下一个流水段没有执行指令。

这里存在流水段的设计问题，特别是乘除法运算部件，根据教材上所说，除法不应该有流水段，而乘法为六段流水段。但是在助教给的pdf上面，介绍的除法为６段流水段，为便于设计和实现，综合实际情况，我们最终设计为乘除法均为６段流水线，统一实现，方便简单。

另外一个问题是Load, Store缓冲队列的问题，书上和pdf上面所讲，均是Load, Store缓冲队列分别存放，但是这样会存在问题，Load, Store指令执行的顺序会不相同，从而导致结果的错误。我们认真仔细的查看了教材和ppt,发现这个算法其实每一个保留站都对应着一个运算部件，因为那个年代并没有发明流水线。也就是如果参考教材和ppt，我们可以一次导入三条指令，或者导出三条指令，这样尽快执行load, store指令，避免出现问题。但是实际上，这样仍然会出现问题，因为store指令需要去等待寄存器准备好，这个时候可能出现load指令先执行的情况，结果不正确。所以，最终，我们的实际方案是load, store缓冲队列合并为一个缓冲队列，这样就没有之前的问题了。

##### kernel.Adder

加法运算部件继承抽象处理类，需要设置流水段和管理的缓冲队列，这些在Adder初始化中完成。之后重载calFunc函数，

- 根据当前操作符为加减的情况，计算结果。
- 之后调用Clock.wake_up函数，将计算结果放到总线上，唤醒各等待该计算结果的保留站和寄存器，之后清空总线数据。

##### kernel.Multiplier

乘法运算部件继承抽象处理类，初始化类似加法运算部件，calFunc函数流程如下：

- 根据当前操作符为乘除的情况，计算结果。
- 之后调用Clock.wake_up函数，将计算结果放到总线上，唤醒各等待该计算结果的保留站和寄存器，之后清空总线数据。

##### kernel.MemAccesser

内存操作运算部件继承抽象处理类，初始化类似加法运算部件，calFunc函数流程如下：

- 根据当前操作符为Load, Store的情况，导入导出内存数据。
- 对于Load操作，需要将计算结果放到总线上，通过调用Clock.wake_up函数。

#### 底层模块

底层模块的设计比较简单，有一点需要提及的是，很多上层模块是这些底层模块的聚合，比如说缓冲队列就是保留站的聚合，流水线就是流水段的聚合。上层模块很多时候需要检查底层模块的状态，比如说缓冲队列中寻找一个可执行的保留站，将指令存入保留站等操作。我们设计方法上面是将所有的这些操作写入到底层模块的静态方法中，这样能够比较好的实现底层模块的变量的封装，同时，能够提供一种比较整齐的代码风格，便于阅读和理解。可以参考Clock.wake_up函数，代码整洁，易于观赏。

##### kernel.FP

寄存器类，设计为单例模式，通过`FP.getInstance()`方法获取实例，内部创建有寄存器名称的枚举类型`REG`，每个寄存器为一个`FloatEntry`,存储　REG --- 寄存器名称，num --- 寄存器值，state --- 寄存器状态。

##### kernel.ReserveStackEntry

保留站类，存有书中提及的７个字段，不在赘述。额外增加的有\_\_id，\_\_name字段，标示保留站的id和名称；Run字段，标识该保留站是否正在被运算部件执行。time字段，标识该保留站已经执行多长时间，供前端显示。

##### kernel.PipeLineSegment

流水段类，初始化保留站需要计算的数据，并设置不同操作指令需要的流水段的各段时间，并对上提供调度算法activate(),某个流水段执行完毕之后，返回需要等待调度(need_schedule)，进入下一个流水段。

##### util.Instr

指令类，基本的指令需要存储的格式，内部定义指令的各种操作码枚举类型

##### util.State

指令运行状态类，表示指令当前的运行状态，有如下几种：

- flow : 指令是否流出
- running : 指令是否正在被运算部件执行
- write_back : 指令是否处于写回状态，包括写入寄存器或者写数据总线
- mark : 这个标签是用来延迟指令的生存周期的作用。正常情况下，一条指令在周期快结束的时候，是出于写回状态的，之后就会被立刻被释放。但是如果这样处理的话，传送给前端的指令状态write_back属性要不就是false状态，或者指令被释放，write_back不会显示为True。所以我将指令释放的周期推迟了一个周期，这样前端运行的时候就能够看到write_back这样一个阶段。

#### 其他

##### util.ConstDefinitions

全局变量定义类，其中定义了一些全局的常量：

- OP_PILELINE_TIME : 各个操作指令所需要的各个流水段周期数，同Instr.OP枚举类型相对应：add, sub, mul, div, load, store。
- FP_NUM, MEM_NUM : 寄存器个数和内存大小
- ADD_RESERVE_ENTRY_NUM, MUL_RESERVE_ENTRY_NUM, MEM_ACCESS_RESERVE_ENTRY_NUM : 各个缓冲队列的代销
- REG_FILENAME, MEM_FILENAME : 导入导出寄存器，内存的文件



